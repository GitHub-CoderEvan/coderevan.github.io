<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Evan Deng"><meta name="keywords" content=""><meta name="description" content="1.垃圾回收 01.三种常见垃圾回收机制 1.0 垃圾回收是什么  传统的系统级编程语言（主要指C&#x2F;C++）中，程序员必须对内存小心的进行管理操作，控制内存的申请及释放。 稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位 后来开发出来的几乎所有新语言（java，python，php等等）都引入了语言层面的自动内存管理 也就是语言的使用者只用关注内存的申请而不必关心内存的释放 内存释放"><meta property="og:type" content="article"><meta property="og:title" content="垃圾回收"><meta property="og:url" content="http://coderedeng.github.io/2021/02/11/Go%E8%BF%9B%E9%98%B6%20-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/index.html"><meta property="og:site_name" content="Deng的博客"><meta property="og:description" content="1.垃圾回收 01.三种常见垃圾回收机制 1.0 垃圾回收是什么  传统的系统级编程语言（主要指C&#x2F;C++）中，程序员必须对内存小心的进行管理操作，控制内存的申请及释放。 稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位 后来开发出来的几乎所有新语言（java，python，php等等）都引入了语言层面的自动内存管理 也就是语言的使用者只用关注内存的申请而不必关心内存的释放 内存释放"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://coderedeng.github.io/img/cover11.png"><meta property="article:published_time" content="2021-02-11T13:24:31.000Z"><meta property="article:modified_time" content="2024-01-22T12:58:59.000Z"><meta property="article:author" content="Evan Deng"><meta property="article:tag" content="Go进阶"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://coderedeng.github.io/img/cover11.png"><title>垃圾回收 - Deng的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"coderedeng.github.io",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Deng的博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Deng&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/books/"><i class="iconfont icon-books"></i> <span>书单</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>博客</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="垃圾回收"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-02-11 21:24" pubdate>2021年2月11日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 30 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">垃圾回收</h1><div class="markdown-body"><h1 id="1-垃圾回收">1.垃圾回收</h1><h2 id="01-三种常见垃圾回收机制">01.三种常见垃圾回收机制</h2><h3 id="1-0-垃圾回收是什么">1.0 垃圾回收是什么</h3><ul><li>传统的系统级编程语言（主要指C/C++）中，程序员必须对内存小心的进行管理操作，控制内存的申请及释放。</li><li>稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位</li><li>后来开发出来的几乎所有新语言（java，python，php等等）都引入了语言层面的自动内存管理</li><li>也就是语言的使用者只用关注内存的申请而不必关心内存的释放</li><li>内存释放由虚拟机（virtual machine）或运行时（runtime）来自动进行管理</li><li>而这种对不再使用的内存资源进行自动回收的行为就被称为垃圾回收。</li></ul><h3 id="1-1-引计数">1.1 引计数</h3><ul><li>原理<ul><li>当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1.</li><li>当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。</li></ul></li><li>优点<ul><li>引用计数有一个很大的优点，即实时性，任何内存，一旦没有指向它的引用，就会被立即回收，而其他的垃圾收集技术必须在某种特殊条件下才能进行无效内存的回收。</li></ul></li><li>缺点<ul><li>引用计数机制所带来的维护引用计数的额外操作与Python运行中所进行的内存分配和释放，引用赋值的次数是成正比的，</li><li>显然比其它那些垃圾收集技术所带来的额外操作只是与待回收的内存数量有关的效率要低。</li><li>同时，因为对象之间相互引用，每个对象的引用都不会为0，所以这些对象所占用的内存始终都不会被释放掉。</li></ul></li></ul><h3 id="1-2-标记－清除">1.2 标记－清除</h3><ul><li>它分为两个阶段：第一阶段是标记阶段，GC会把所有的活动对象打上标记，第二阶段是把那些没有标记的对象非活动对象进行回收。</li><li>对象之间通过引用（指针）连在一起，构成一个有向图</li><li>从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。</li><li>根对象就是全局变量、调用栈、寄存器。</li></ul><p><img src="/img/image-20210603162801815.fc6c7a54.png" srcset="/img/loading.gif" lazyload alt="img"></p><ul><li>在上图中，可以从程序变量直接访问块1，并且可以间接访问块2和3,程序无法访问块4和5</li><li>第一步将标记块1，并记住块2和3以供稍后处理。</li><li>第二步将标记块2，第三步将标记块3，但不记得块2，因为它已被标记。</li><li>扫描阶段将忽略块1，2和3，因为它们已被标记，但会回收块4和5。</li></ul><h3 id="1-3-分代回收">1.3 分代回收</h3><ul><li>分代回收是建立在标记清除技术基础之上的，是一种以空间换时间的操作方式。</li><li>Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代）</li><li>他们对应的是3个链表，它们的<strong>垃圾收集频率与对象的存活时间的增大而减小</strong>。</li><li>新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发</li><li>把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推</li><li>老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。</li></ul><h2 id="02-Golang-三色标记法">02.Golang-三色标记法</h2><h3 id="2-1-三色标记法介绍">2.1 三色标记法介绍</h3><ul><li><p>三色标记法只是为了叙述方便而抽象出来的一种说法，实际上的对象是没有三色之分的。</p></li><li><p>这里的三色，对应了垃圾回收过程中对象的三种状态：</p></li><li><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">1）灰色（可能指向其他白色）
<pre class="line-numbers language-none"><code class="language-none">
  ：对象还在标记队列中等待

  - 已被回收器访问到的对象，不会被回收
  - 但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象

- &#96;&#96;&#96;
  2）黑色（不指向其他白色）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></div></figure>：对象已被标记，<figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">gcmarkBits<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>对应位为<figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>-- 该对象不会在本次 GC 中被回收 - 已被回收器访问到的对象，其中所有字段都已被扫描 - 黑色对象中任何一个指针都不可能直接指向白色对象</li><li><p><code>3）白色（要被清除的）</code>：对象未被标记，<code>gcmarkBits</code> 对应位为 <code>0</code> – 该对象将会在本次 GC 中被清理</p></li></ul><h3 id="2-2-具体流程如下图">2.2 具体流程如下图</h3><ul><li>就是标记内存中那些还在使用中（即被引用了）的部分</li><li>而内存中不再使用（即未被引用）的部分，就是要回收的垃圾，需要将其回收</li><li>上图中的 A、B、D 就是被引用正在使用的内存</li><li>而 C、F、E 曾经被使用过，但现在没有任何对象引用，就需要被回收掉。</li><li>而 Root 区域主要是程序运行到当前时刻的栈和全局数据区域，是实时正在使用到的内存，当然应该优先标记。</li><li>而考虑到内存块中存放的可能是指针，所以还需要递归的进行标记，待全部标记完后，就会对未被标记的内存进行回收。</li></ul><p><img src="/img/image-20210603171414358.015b0755.png" srcset="/img/loading.gif" lazyload alt="img"></p><h3 id="2-3-STW弊端和优化">2.3 STW弊端和优化</h3><ul><li>STW弊端<ul><li>golang 的垃圾回收算法属于 <strong>标记-清除</strong>，是需要 STW 的</li><li>STW 就是 <strong>Stop The World</strong> 的意思，在 golang 中就是要停掉所有的 goroutine，专心进行垃圾回收，待垃圾回收结束后再恢复 goroutine</li><li>而 STW 时间的长短直接影响了应用的执行，如果时间过长，那将是灾难性的。</li><li>为了缩短 STW 时间，golang 不对优化垃圾回收算法</li><li>其中**写屏障（Write Barrier）<strong>和</strong>辅助 GC（Mutator Assist）**就是两种优化垃圾回收的方法</li></ul></li><li><strong><code>1）写屏障（Write Barrier）</code></strong><ul><li>而写屏障就是让 goroutine 与 GC 同时运行的手段，虽然不能完全消除 STW，但是可以大大减少 STW 的时间。</li><li>写屏障在 GC 的特定时间开启，开启后指针传递时会把指针标记，即本轮不回收，下次 GC 时再确定。</li></ul></li><li><strong><code>2）辅助 GC（Mutator Assist）</code></strong><ul><li>为了防止内存分配过快，在 GC 执行过程中</li><li>GC 过程中 mutator 线程会并发运行，而 mutator assist 机制会协助 GC 做一部分的工作</li></ul></li></ul><h3 id="2-4-写屏障">2.4 写屏障</h3><h4 id="1、STW解决的问题">1、STW解决的问题</h4><ul><li><code>标记过程需的要STW</code>，因为对象引用关系如果在标记阶段做了修改，<code>会影响标记结果的正确性</code>。</li><li>例如下图（假设没有STW）<ul><li>1）灰色对象B引用白色对象C（此时C尚未被扫描）</li><li>2）当遍历完A对象后，A变成黑色<ul><li>如果有其他程序断开了B对C的引用</li><li>同时添加了A对C的引用（由于A是黑色，所以C会一直是白色，被回收）</li></ul></li></ul></li></ul><p><img src="/img/image-20220401211153112.d1d09a94.png" srcset="/img/loading.gif" lazyload alt="img"></p><h4 id="2、屏障技术">2、屏障技术</h4><ul><li><code>1）强三色不变式</code>：强三色不变式很好理解，强制性的不允许黑色对象引用白色对象即可<ul><li><code>插入屏障</code>：插入屏障拦截将白色指针插入黑色对象的操作，标记其对应对象为灰色状态</li></ul></li><li><code>2）弱三色不变式</code>：所有被黑色对象引用的白色对象都处于灰色保护状态<ul><li><code>删除屏障</code>：也是拦截写操作的，但是是通过保护灰色对象到白色对象的路径不会断来实现的</li><li>被灰色引用的对象，被删除了最后一个指向它的指针，也依旧可以活过这一轮，在下一轮GC中被清理掉</li></ul></li></ul><h4 id="3、混合写屏障">3、混合写屏障</h4><ul><li><p><code>插入屏障 优缺点</code></p><ul><li>插入写屏障在标记开始时无需STW，可直接开始，并发进行</li><li>但结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活</li></ul></li><li><p><code>删除屏障 优缺点</code></p><ul><li>删除写屏障则需要在GC开始时STW扫描堆栈来记录初始快照</li><li>这个过程会保护开始时刻的所有存活对象，但结束时无需STW</li></ul></li><li><p><code>Go1.8版本引入的混合写屏障</code></p><ul><li>同样允许黑色对象引用白色对象，白色对象处于灰色保护状态，但是<code>只由堆上的灰色对象保护</code>。</li><li>只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW</li><li>而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</li></ul></li><li><p><code>混合写屏障两种情况</code></p><ul><li><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">灰色对象B在堆上
<pre class="line-numbers language-none"><code class="language-none">
  - 一个堆上的灰色对象B，引用白色对象C，在GC并发运行的过程中
  - 如果栈已扫描置黑，而赋值器&#96;将指向C的唯一指针从B中删除&#96;，&#96;并让栈上其他对象引用它&#96;
  - 这时，写屏障会在删除指向白色对象C的指针的时候&#96;就将C对象置灰&#96;，就可以保护下来了

- &#96;&#96;&#96;
  灰色对象B在栈上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></div></figure>- 灰色对象B在栈上，引用堆上的白色对象C，将其引用关系删除，且新增一个黑色对象到对象C的引用 - 那么就需要通过shade(ptr)来保护了，在指针插入黑色对象时会触发对对象C的置灰操作。 - 如果栈已经被扫描过了，那么栈上引用的对象都是灰色或受灰色保护的白色对象了，所以就没有必要再进行这步操作。</li></ul></li></ul><h3 id="2-5-垃圾回收触发机制">2.5 垃圾回收触发机制</h3><ul><li>1、内存分配量达到阈值<ul><li>每次内存分配都会检查当前内存分配量是否达到阈值，如果达到阈值则触发 GC。</li><li><code>阈值 = 上次 GC 内存分配量 * 内存增长率</code></li><li>内存增长率由环境变量 <code>GOGC</code> 控制，默认为 100，即每当内存扩大一倍时启动 GC。</li></ul></li><li>2、定时触发 GC<ul><li>默认情况下，2 分钟触发一次 GC，该间隔由 <code>src/runtime/proc.go</code> 中的 <code>forcegcperiod</code> 声明。</li></ul></li><li>3、手动触发 GC<ul><li>在代码中，可通过使用 <code>runtime.GC()</code> 手动触发 GC。</li></ul></li></ul><h3 id="2-6-GC-优化建议">2.6 GC 优化建议</h3><ul><li>由上文可知，GC 性能是与对象数量有关的，对象越多 GC 性能越差，对程序的影响也越大。</li><li>所以在开发中要尽量减少对象分配个数，采用对象复用、将小对象组合成大对象或采用小数据类型（如使用 <code>int8</code> 代替 <code>int</code>）等。</li></ul><h3 id="2-7-结语">2.7 结语</h3><ul><li>一门编程语言的垃圾回收机制会直接影响使用其开发应用的性能。</li><li>在日常开发工作中也因注意到其作用，有助于开发出高性能的应用，这也是 GC 常常在面试中被问到的原因。</li><li>同时，了解 GC 对了解内存管理也很有帮助。</li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Go%E8%BF%9B%E9%98%B6/" class="category-chain-item">Go进阶</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Go%E8%BF%9B%E9%98%B6/">#Go进阶</a></div></div><div class="license-box my-3"><div class="license-title"><div>垃圾回收</div><div>http://coderedeng.github.io/2021/02/11/Go进阶 - 垃圾回收/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Evan Deng</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2021年2月11日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2021/02/12/Go%E8%BF%9B%E9%98%B6%20-%20%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" title="深浅拷贝"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">深浅拷贝</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2021/02/10/Go%E8%BF%9B%E9%98%B6%20-%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/" title="内存泄露"><span class="hidden-mobile">内存泄露</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>